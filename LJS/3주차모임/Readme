## BOJ 벽 부수고 이동하기

- [O] N의 크기를 확인 하였는가?
- [O] 문제 제약사항을 확인 하였는가?
- [x] 시간복잡도를 계산 할 수 있는가?
- [O] 적절한 자료구조 활용하였는가?
- [O] 핵심 알고리즘을 구현할 수 있는가?
- [O] 문제를 풀었는가?

visited[1000][1000][11]의 메모리 사용량이 visited[11][1000][1000]의 메모리 사용량의 약 2배 정도이다.
가장 큰 길이의 차원을 가장 오른쪽에 놓는 것이 메모리가 가장 절약된다.
이에 대한 이유는 공간지역성과 (Java에서는) 헤더의 수 차이 때문이라는 것을 게시판에서 확인할 수 있었다.
visited[1000][1000][11]: 478536 KB / 6984 ms
visited[11][1000][1000]: 338688 KB / 3812 ms


벽뿌 1과 동일한 로직이지만 visited배열을 K+1 size만큼으로 생성해줘야 벽을 몇 번 부쉈는지 저장할 수 있었다.


