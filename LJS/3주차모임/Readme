## BOJ 벽 부수고 이동하기

- [O] N의 크기를 확인 하였는가?
- [O] 문제 제약사항을 확인 하였는가?
- [x] 시간복잡도를 계산 할 수 있는가?
- [O] 적절한 자료구조 활용하였는가?
- [O] 핵심 알고리즘을 구현할 수 있는가?
- [O] 문제를 풀었는가?

visited[1000][1000][11]의 메모리 사용량이 visited[11][1000][1000]의 메모리 사용량의 약 2배 정도이다.
가장 큰 길이의 차원을 가장 오른쪽에 놓는 것이 메모리가 가장 절약된다.
이에 대한 이유는 공간지역성과 (Java에서는) 헤더의 수 차이 때문이라는 것을 게시판에서 확인할 수 있었다.
visited[1000][1000][11]: 478536 KB / 6984 ms
visited[11][1000][1000]: 338688 KB / 3812 ms


벽뿌 1과 동일한 로직이지만 visited배열을 K+1 size만큼으로 생성해줘야 벽을 몇 번 부쉈는지 저장할 수 있었다.


## BOJ 양팔저울

- [O] N의 크기를 확인 하였는가?
- [O] 문제 제약사항을 확인 하였는가?
- [O] 시간복잡도를 계산 할 수 있는가?
- [O] 적절한 자료구조 활용하였는가?
- [O] 핵심 알고리즘을 구현할 수 있는가?
- [O] 문제를 풀었는가?

DP 배열을 40001로 선언해준후, 0부터 시작해서 추의 무게를 빼거나, 더하는 경우를 DP배열로 저장해줬다.
범위를 넘지 않는 선에서 DP의 값을 바꿔주었고, 중복되게 계산하지 않도록 temp_li에 저장해뒀다가,
한번에 1로 바꾸는 식으로 로직을 짰다.

문제에서 요구하는 값이 dp배열에서 1이면 Y 0이면 N을 출력하면 된다.
