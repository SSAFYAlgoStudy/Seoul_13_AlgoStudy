## BOJ 트리의 부모찾기

- [x] N의 크기를 확인 하였는가?
- [x] 문제 제약사항을 확인 하였는가?
- [x] 시간복잡도를 계산 할 수 있는가?
- [x] 적절한 자료구조 활용하였는가?
- [x] 핵심 알고리즘을 구현할 수 있는가?
- [x] 문제를 풀었는가?

  - 핵심 IDEA
    - 루트로부터 시작하여 자식 노드를 호출할때마다 parent 라는 배열에 지속적인 update
    - 재귀를 통해 solve. 시간복잡도 O(N + E) n = 노드의 개수 e = 간선의 개수

-------------------------------------------------------------------------------

## BOJ 링크와 스타트

- [x] N의 크기를 확인 하였는가?
- [x] 문제 제약사항을 확인 하였는가?
- [x] 시간복잡도를 계산 할 수 있는가?
- [x] 적절한 자료구조 활용하였는가?
- [x] 핵심 알고리즘을 구현할 수 있는가?
- [x] 문제를 풀었는가?
- 
  - 핵심 IDEA
    - BITMASK 를 통해 부분집합을 생성한뒤 비트열이 1이면 team1에 0 이면 team2에 할당.
    - 위의 과정을 통해 O(2^n) 시간에 모든 팀들의 분배를 완료.
  
-------------------------------------------------------------------------------

## 양과 늑대

- [x] N의 크기를 확인 하였는가? max(n) = 17
- [x] 문제 제약사항을 확인 하였는가? n <= 17
- [x] 시간복잡도를 계산 할 수 있는가? O(2^n)
- [x] 적절한 자료구조 활용하였는가? binary tree or graph
- [x] 핵심 알고리즘을 구현할 수 있는가? bitmasking + recursivefunction
- [x] 문제를 풀었는가?
- 
  - 핵심 IDEA
    - BITMASK 를 통해 모든 서브 그래프의 상태를 표현할 수 있다.
    - 현재 상태(bitmasked)에서 현재 마스킹된 노드 기준으로 다음 자식노드를 호출하여 다음 상태를 표현 할 수 있다.